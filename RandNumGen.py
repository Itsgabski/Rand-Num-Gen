import pyautogui #გამოსაყენებლად ტერმინალში გავუშვათ pip install pyautogui
import time #time არის დროის ბიბლიოთეკა
import requests #გამოსაყენებლად ტერმინალში გავუშვათ pip install requests

def Rand16BitNumGen():
    # pyautogui არის ბიბლიოთეკა, რომელიც თვალს ადევნებს მაუსსა და კლავიატურას და შეუძლია დაგვიბრუნოს ინფორმაცია მათ შესახებ
    # მათ შორისაა pyautogui.position ფუნქცია, რომელიც აბრუნებს მაუსის კურსორის კოორდინატებს ეკრანზე
    x, y = pyautogui.position() #x-ს და y-ს გადავცემთ კოორდინატების მნიშვნელობებს

    t = time.perf_counter_ns() # time ბიბლიოთეკის perf_counter_ns() ფუნქცია აბრუნებს რამდენი დრო გავიდა სისტემის თვითნებური საწყისი წერტილიდან ნანოწამებში, რომელიც ცხადია მუდმივად იცვლება

    shift_x = (x ^ t) % 8 + 4  # shift_x არის ის რიცხვი რამდენითაც უნდა გადავწიოთ ბიტურად x კოორდინატის მნიშვნელობა
    shift_y = (y ^ t) % 8 + 4  # shift_y არის ის რიცხვი რამდენითაც უნდა გადავწიოთ ბიტურად y კოორდინატის მნიშვნელობა
    #ორივე შემთხვევაში კოორდინატის მნიშვნელობას XOR-ავთ დროის t მნიშვნელობაზე, შემდგომ ვნაშთავთ 8-ზე, რათა მათი მნიშვნელობები იყოს 0-დან 7-ის ჩათვლით, მაგრამ რომ ვუმატებთ 4-ს, შუალედი ხდება 4-დან 11-ის ჩათვლით

    mixed = (x << shift_x) ^ (y << shift_y) ^ t #mixed ცვლადში ვინახავთ x-ის და y-ს შესაბამისად shift_x-ითა და shift_y-ით ბიტურად მარცხნივ გადაწევის შედეგებისა და t დროის მნიშვნელობების ერთმანეთზე "გაქსორვით"

    try:
        data = requests.get('https://api.coindesk.com/v1/bpi/currentprice.json').json() #requests ბიბლიოთეკა გვეხმარება API-ით წამოვიღოთ ინფორმაცია, get()-ს გადავცემთ API-ს და json() გარდაქმნის მას ან list-ად ან dictionary-ად
        bitcvalue = int(data['bpi']['USD']['rate_float'])  #მიღებული data-დან ვიღებთ ბიტკოინის ფასს ა.შ.შ დოლარებში და გადაგვყავს int-ში
    except:
        bitcvalue = int(time.time() * 1000)  # თუ ვერ მივიღეთ API-ით მონაცემები, მაშინ ავიღოთ დრო წამებში Unix-ის ეპოქიდან (01/01/1970 00:00:00 UTC) და გავამრავლოთ 1000-ზე და გადავაქციოთ int-ად

    # "გავქსოროთ" mixed და bitcvalue
    mixed_final = mixed ^ bitcvalue

    # 0xFFFF არის თექვსმეტობითი რიცხვი, რომელიც ათწილადში წარმოადგენს 65535-ს
    # "& 0xFFFF"-ის გამოყენება იძლევა რიცხვის ყველაზე დაბალ 16 ბიტს, რაც საბოლოოდ იძლევა 16-ბიტიან შემთხვევით რიცხვს
    random_16bit = mixed_final & 0xFFFF

    print("Random 16 bit number: ",random_16bit)

Rand16BitNumGen()
Rand16BitNumGen()
Rand16BitNumGen()
Rand16BitNumGen()
Rand16BitNumGen()


